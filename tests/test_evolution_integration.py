"""
Integration tests for the evolution system with QADI agents.

These tests verify that the genetic algorithm works correctly with
the existing QADI infrastructure.
"""

from datetime import datetime

import pytest

from mad_spark_alt.agents.abduction import AbductionAgent
from mad_spark_alt.agents.questioning import QuestioningAgent
from mad_spark_alt.core import (
    IdeaGenerationRequest,
    QADIOrchestrator,
    agent_registry,
    register_agent,
)
from mad_spark_alt.evolution import (
    EvolutionConfig,
    EvolutionRequest,
    GeneticAlgorithm,
    SelectionStrategy,
)


class TestEvolutionIntegration:
    """Integration tests for evolution with QADI system."""

    def setup_method(self):
        """Set up test environment."""
        # Clear and register agents
        agent_registry.clear()
        register_agent(QuestioningAgent)
        register_agent(AbductionAgent)

    def teardown_method(self):
        """Clean up after tests."""
        agent_registry.clear()

    @pytest.mark.asyncio
    async def test_evolve_qadi_generated_ideas(self):
        """Test evolving ideas generated by QADI agents."""
        # Generate initial ideas using QADI agents
        agents = [
            agent_registry.get_agent("QuestioningAgent"),
            agent_registry.get_agent("AbductionAgent"),
        ]

        orchestrator = QADIOrchestrator([a for a in agents if a])

        # Generate ideas
        qadi_result = await orchestrator.run_qadi_cycle(
            problem_statement="How can we make renewable energy more accessible?",
            context="Focus on practical solutions for developing regions",
            cycle_config={"max_ideas_per_method": 3},
        )

        # Verify we have ideas to evolve
        assert len(qadi_result.synthesized_ideas) > 0

        # Create genetic algorithm
        ga = GeneticAlgorithm()

        # Configure evolution
        config = EvolutionConfig(
            population_size=10,
            generations=3,
            mutation_rate=0.2,
            crossover_rate=0.7,
            elite_size=2,
            parallel_evaluation=False,  # Disable for testing
        )

        # Create evolution request
        request = EvolutionRequest(
            initial_population=qadi_result.synthesized_ideas[:10],  # Use up to 10 ideas
            config=config,
            context="Optimize for practicality and cost-effectiveness",
        )

        # Run evolution
        evolution_result = await ga.evolve(request)

        # Verify evolution results
        assert evolution_result.success
        assert len(evolution_result.final_population) == config.population_size
        assert len(evolution_result.best_ideas) > 0
        assert evolution_result.total_generations > 0

        # Check that ideas evolved (content changed)
        initial_contents = {idea.content for idea in qadi_result.synthesized_ideas[:10]}
        final_contents = {idea.content for idea in evolution_result.best_ideas}

        # Some ideas should be different after evolution
        assert not initial_contents == final_contents

        # Verify fitness improvements
        initial_fitness = evolution_result.generation_snapshots[0].average_fitness
        final_fitness = evolution_result.generation_snapshots[-1].average_fitness

        # Average fitness should generally improve or stay similar
        assert (
            final_fitness >= initial_fitness * 0.9
        )  # Allow small decrease due to randomness

        # Check evolution metrics
        assert "fitness_improvement_percent" in evolution_result.evolution_metrics
        assert "fitness_trend" in evolution_result.evolution_metrics
        assert (
            len(evolution_result.evolution_metrics["fitness_trend"])
            == evolution_result.total_generations
        )

    @pytest.mark.asyncio
    async def test_evolution_preserves_thinking_methods(self):
        """Test that evolution preserves thinking method diversity."""
        # Create ideas with different thinking methods
        questioning_agent = agent_registry.get_agent("QuestioningAgent")
        abduction_agent = agent_registry.get_agent("AbductionAgent")

        request = IdeaGenerationRequest(
            problem_statement="How to improve education accessibility?",
            max_ideas_per_method=5,
        )

        # Generate ideas from different agents
        q_result = await questioning_agent.generate_ideas(request)
        a_result = await abduction_agent.generate_ideas(request)

        # Create a larger, balanced initial population
        mixed_ideas = q_result.generated_ideas[:5] + a_result.generated_ideas[:5]

        # Evolve the mixed population
        ga = GeneticAlgorithm()

        config = EvolutionConfig(
            population_size=10,  # Larger population for better diversity
            generations=2,
            mutation_rate=0.1,
            crossover_rate=0.8,
            elite_size=4,  # Preserve top ideas from both methods
            selection_strategy=SelectionStrategy.TOURNAMENT,
        )

        evolution_request = EvolutionRequest(
            initial_population=mixed_ideas, config=config
        )

        result = await ga.evolve(evolution_request)

        # Check that thinking methods are represented in the final population
        final_methods = {ind.idea.thinking_method for ind in result.final_population}

        # With elite preservation and balanced initial population,
        # we should maintain some diversity, but perfect balance isn't guaranteed
        # as fitness drives selection
        assert len(final_methods) >= 1  # At least one method preserved

        # Check that evolution occurred (some ideas changed)
        initial_contents = {idea.content for idea in mixed_ideas}
        final_contents = {ind.idea.content for ind in result.final_population}
        assert initial_contents != final_contents

    @pytest.mark.asyncio
    async def test_evolution_with_constraints(self):
        """Test evolution with specific constraints."""
        # Generate initial ideas
        agent = agent_registry.get_agent("QuestioningAgent")
        request = IdeaGenerationRequest(
            problem_statement="How to reduce carbon emissions in cities?",
            max_ideas_per_method=5,
        )

        gen_result = await agent.generate_ideas(request)

        # Create genetic algorithm
        ga = GeneticAlgorithm()

        # Configure with specific targets
        config = EvolutionConfig(
            population_size=5,
            generations=5,
            mutation_rate=0.15,
            crossover_rate=0.75,
            elite_size=1,
            fitness_weights={
                "creativity_score": 0.3,
                "diversity_score": 0.4,  # Emphasize diversity
                "quality_score": 0.3,
            },
        )

        evolution_request = EvolutionRequest(
            initial_population=gen_result.generated_ideas,
            config=config,
            constraints=[
                "Solutions must be implementable within 5 years",
                "Focus on existing technology",
                "Consider economic viability",
            ],
            target_metrics={"min_fitness": 0.7},
        )

        result = await ga.evolve(evolution_request)

        # Verify results
        assert result.success

        # Check that best ideas have reasonable fitness
        if result.best_ideas:
            # The evolution should produce ideas, even if fitness target isn't met
            assert len(result.best_ideas) > 0

    @pytest.mark.asyncio
    async def test_evolution_error_handling(self):
        """Test evolution handles errors gracefully."""
        # Create genetic algorithm
        ga = GeneticAlgorithm()

        # Test with empty population
        request = EvolutionRequest(initial_population=[], config=EvolutionConfig())

        result = await ga.evolve(request)

        assert not result.success
        assert result.error_message is not None

        # Test with invalid config
        agent = agent_registry.get_agent("QuestioningAgent")
        gen_request = IdeaGenerationRequest(
            problem_statement="Test problem", max_ideas_per_method=1
        )
        gen_result = await agent.generate_ideas(gen_request)

        invalid_config = EvolutionConfig(population_size=0, generations=5)  # Invalid

        request = EvolutionRequest(
            initial_population=gen_result.generated_ideas, config=invalid_config
        )

        result = await ga.evolve(request)

        assert not result.success
        assert result.error_message is not None
